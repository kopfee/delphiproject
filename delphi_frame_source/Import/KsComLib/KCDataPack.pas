unit KCDataPack;

{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 1999 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      FINAL DELPHI-JEDI COMMANDLINE EDITION                               }
{                                                                          }
{    Generated Date:  2001-6-21                                            }
{    Generated Time: 15:10:47                                              }
{                                                                          }
{**************************************************************************}

{-创建日期： 2001/6/12 }
{-作者： 史光伟 }
{-版本信息： V1.0.2 }
{-功能： }
{-正式的包结构/压包解包 }
{-和1.0.1版本的区别： }
{-1.0.1版本使用的是旧的格式的pack结构， }
{-1.0.2版本用的是讨论过后的新的pack结构 }
{-------------------------------------------------------------------------- }

{-修改日期： 2001/6/12 }
{-修改人： 史光伟 }
{-修改描述： 建立了cpack结构 }

// modified by Huang Yanlai

interface

uses Windows;

{=> CPACK.H <=}

const
  MAXPACKAGESIZE = 32*1024;
  PARAMBITS = 256;
  BITSPERBYTE = 8;
  ParamBitsSize = PARAMBITS div BITSPERBYTE;
  // log category
  lcKCPack = 7;
  lcKCPackDetail = 13;

type
  TSTADDR = array[0..5] of Byte;
  TSTParamBits =  array[0..ParamBitsSize-1] of Byte;

  TSTCookie = packed record
    UserID: LongWord;     {= 请求者的ID号码 }
    (*
    hostname: LongWord;   {= 主机名 }
    queuename: LongWord;  {= 队列名 }
    *)
    hostname: array[0..33-1] of Char;   {= 主机名 }
    queuename: array[0..33-1] of Char;  {= 队列名 }
    queuetype: LongWord;  {= 队列类型 }
  end;

  TSTDataHead = packed record
    RequestType : LongWord;			// 交易编码，4字节
	  FirstFlag   : Byte ;				// 是否第一个请求（首包请求）
	  NextFlag    : Byte ;				// 是否后续包请求
	  RecCount    : LongWord;			// 本包的记录数
	  RetCode     : LongWord;		  // 返回代码
	  Addr        : TSTADDR;			// 请求着的地址（6个子节）
    Cookie      : TSTCookie;
    userdata    : LongWord;
	  ParamBits   : TSTParamBits;
  end;
  PSTDataHead = ^TSTDataHead;

  TSTPack = packed record
    scust_no: array[0..11-1] of Char;       {=1 客户号 }
    scust_no2: array[0..11-1] of Char;      {= 第二客户号 }
    sholder_ac_no: array[0..16-1] of Char;  {= 股东代码 }
    sholder_ac_no2: array[0..16-1] of Char; {= 第二股东代码 }
    sholder_type: array[0..3-1] of Char;    {= 股东代码类别 }
    sholder_type2: array[0..3-1] of Char;   {= 第二股东代码类别 }
    sname: array[0..21-1] of Char;          {= 姓名 }
    sname2: array[0..21-1] of Char;         {= 第二姓名 }

    sall_name: array[0..81-1] of Char;      {=2 全名 }
    smarket_code: array[0..2-1] of Char;    {= 市场代码 }
    smarket_code2: array[0..2-1] of Char;   {= 市场代码2 }
    sdate0: array[0..9-1] of Char;          {= 日期 委托日期 }
    sdate1: array[0..9-1] of Char;          {= 日期 成交日期 }
    sdate2: array[0..9-1] of Char;          {= 日期 报盘日期 }
    sdate3: array[0..9-1] of Char;          {= 日期 发生日期 }
    stime0: array[0..9-1] of Char;          {= 时间 委托时间 }

    stime1: array[0..9-1] of Char;          {=3 时间 成交时间 }
    stime2: array[0..9-1] of Char;          {= 时间 包盘时间 }
    stime3: array[0..9-1] of Char;          {= 时间 发生时间 }
    lvol0: LongInt;                         {= 数量0 委托数量 买量1 }
    lvol1: LongInt;                         {= 数量1 成交数量 买量2 }
    lvol2: LongInt;                         {= 数量2 可用数量 买量3 }
    lvol3: LongInt;                         {= 数量3 手工冻结数量 买量4 }
    lvol4: LongInt;                         {= 数量4 委托冻结数量 卖量1 }

    lvol5: LongInt;                         {=4 数量5 买入成交数量 卖量2 }
    lvol6: LongInt;                         {= 数量6 卖出成交数量 卖量3 }
    lvol7: LongInt;                         {= 数量7 清算后余额 卖量4 }
    lvol8: LongInt;                         {= 数量8 手工解冻数量 }
    lvol9: LongInt;                         {= 数量9 存入数量 }
    lvol10: LongInt;                        {= 数量10 取出数量 }
    lvol11: LongInt;                        {= 数量11 买入未过户数量 }
    lvol12: LongInt;                        {= 数量12 卖出未过户数量 }

    damt0: Double;                          {=5 金额0 委托价格 }
    damt1: Double;                          {= 金额1 委托金额 }
    damt2: Double;                          {= 金额2 成交价格 }
    damt3: Double;                          {= 金额3 成交金额 }
    damt4: Double;                          {= 金额4 清算后余额 }
    damt5: Double;                          {= 金额5 存入金额 }
    damt6: Double;                          {= 金额6 取出金额 }
    damt7: Double;                          {= 金额7 现金金额 }

    damt8: Double;                          {=6 金额8 支汇票金额 }
    damt9: Double;                          {= 金额9 异常冻结金额 }
    damt10: Double;                         {= 金额10 买入冻结金额 }
    damt11: Double;                         {= 金额11 卖出冻结金额 }
    damt12: Double;                         {= 金额12 买入成交金额 }
    damt13: Double;                         {= 金额13 卖出成交金额 }
    damt14: Double;                         {= 金额14 手工冻结金额 }
    damt15: Double;                         {= 金额15 手工解冻金额 }

    damt16: Double;                         {=7 金额16 贷款金额 }
    damt17: Double;                         {= 金额17 发生金额 }
    damt18: Double;                         {= 金额18 买入未过户金额 }
    damt19: Double;                         {= 金额19 卖出未过户金额 }
    damt20: Double;                         {= 金额20 利息积数 }
    damt21: Double;                         {= 金额21 罚息积数 }
    damt22: Double;                         {= 金额22 贷款利息9积数 }
    damt23: Double;                         {= 金额23 信用金额 }

    damt24: Double;                         {=8 金额24 禁用资金 }
    damt25: Double;                         {= 金额25 禁取资金 }
    damt26: Double;                         {= 金额26 利息 }
    damt27: Double;                         {= 金额27 罚息 }
    damt28: Double;                         {= 金额28 贷款利息 }
    damt29: Double;                         {= 金额29 市值 }
    damt30: Double;                         {= 金额30 虚增保证金 }
    damt31: Double;                         {= 金额31 手续费 }

    damt32: Double;                         {=9 金额32 印花税 }
    damt33: Double;                         {= 金额33 过户费 }
    sstock_code: array[0..9-1] of Char;     {= 证券代码 }
    sstock_code2: array[0..9-1] of Char;    {= 证券代码2 }
    scust_type: array[0..3-1] of Char;      {= 客户类别 }
    scust_type2: array[0..3-1] of Char;     {= 客户类别2 }
    sstat_type: array[0..3-1] of Char;      {= 统计类别 }
    sstat_type2: array[0..3-1] of Char;     {= 统计类别2 }

    sroom_no: array[0..4-1] of Char;        {=10 客户组号 }
    sroom_no2: array[0..4-1] of Char;       {= 客户组号2 }
    sopen_emp: array[0..7-1] of Char;       {= 职工 }
    sclose_emp: array[0..7-1] of Char;      {= 职工 }
    schange_emp: array[0..7-1] of Char;     {= 职工 }
    scheck_emp: array[0..7-1] of Char;      {= 复核职工 }
    semp: array[0..7-1] of Char;            {= 职工 }
    snation_code: array[0..4-1] of Char;    {= 国籍代码 }

    lcert_code: LongInt;                    {=11 证件类别 }
    stx_pwd: array[0..9-1] of Char;         {= 交易密码 }
    stx_pwd2: array[0..9-1] of Char;        {= 交易密码2 }
    swithdraw_pwd: array[0..9-1] of Char;   {= 取款密码 }
    swithdraw_pwd2: array[0..9-1] of Char;  {= 取款密码2 }
    semp_pwd: array[0..9-1] of Char;        {= 柜员密码 }
    semp_pwd2: array[0..9-1] of Char;       {= 柜员密码2 }
    sbank_pwd: array[0..9-1] of Char;       {= 银行密码 }

    sbank_pwd2: array[0..9-1] of Char;      {=12 银行密码2 }
    scust_auth: array[0..21-1] of Char;     {= 客户权限 }
    scust_auth2: array[0..21-1] of Char;    {= 客户权限2 }
    scust_limit: array[0..33-1] of Char;    {= 客户限制 }
    scust_limit2: array[0..33-1] of Char;   {= 客户限制2 }
    lsafe_level: LongInt;                   {= 安全级别 }
    lsafe_level2: LongInt;                  {= 安全级别2 }
    spost_code: array[0..7-1] of Char;      {= 邮政编码 }

    spost_code2: array[0..7-1] of Char;     {=13 邮政编码2 }
    sphone: array[0..31-1] of Char;         {= 联系电话 }
    sphone2: array[0..31-1] of Char;        {= fax }
    sphone3: array[0..31-1] of Char;        {= 移动电话 }
    spager: array[0..31-1] of Char;         {= 传呼 }
    semail: array[0..61-1] of Char;         {= email }
    semail2: array[0..61-1] of Char;        {= email2 }
    snote: array[0..81-1] of Char;          {= 备注 }

    snote2: array[0..81-1] of Char;         {=14 备注2 }
    scert_no: array[0..51-1] of Char;       {= 身份证号码 }
    scert_no2: array[0..51-1] of Char;      {= 身份证号码2 }
    scert_addr: array[0..81-1] of Char;     {= 身份证地址 }
    sstatus0: array[0..2-1] of Char;        {= 状态，客户状态 }
    sstatus1: array[0..2-1] of Char;        {= 状态1 }
    sstatus2: array[0..2-1] of Char;        {= 状态2 }
    sstatus3: array[0..2-1] of Char;        {= 状态3 }

    sstatus4: array[0..2-1] of Char;        {=15 状态4 }
    lwithdraw_flag: LongInt;                {= 提款方式 }
    saddr: array[0..81-1] of Char;          {= 联系地址 }
    saddr2: array[0..81-1] of Char;         {= 联系地址2 }
    sserial0: array[0..13-1] of Char;       {= 序号0 }
    sserial1: array[0..13-1] of Char;       {= 序号1 }
    sserial2: array[0..13-1] of Char;       {= 序号2 }
    sserial3: array[0..13-1] of Char;       {= 序号3 }

    sserial4: array[0..13-1] of Char;       {=16 序号4 }
    scurrency_type: array[0..3-1] of Char;  {= 货币类型 }
    scurrency_type2: array[0..3-1] of Char; {= 货币类型2 }
    sbranch_code0: array[0..4-1] of Char;   {= 开户营业部号码 }
    sbranch_code1: array[0..4-1] of Char;   {= 发生营业部号码 }
    sbranch_code2: array[0..4-1] of Char;   {= 营业部号码2 }
    usset0: array[0..100-1] of Byte;        {= 管理权限集合 }
    usset1: array[0..100-1] of Byte;        {= 授权权限集合 }

    usset2: array[0..100-1] of Byte;        {=17 操作权限集合 }
    usset3: array[0..100-1] of Byte;        {= 菜单权限集合 }
    usset4: array[0..100-1] of Byte;        {= 岗位集合 }
    usset5: array[0..100-1] of Byte;        {= 市场集合 }
    usset6: array[0..100-1] of Byte;        {= 货币集合 }
    sstation0: array[0..17-1] of Char;      {= 工作站地址 }
    sstation1: array[0..17-1] of Char;      {= 工作站地址2 }
    sbank_acc: array[0..41-1] of Char;      {= 银行账号 }

    sbank_acc2: array[0..41-1] of Char;     {=18 银行账号2 }
    lbank_acc_type: LongInt;                {= 银行账号类别 }
    lbank_acc_type2: LongInt;               {= 银行账号类别2 }
    smain_flag: array[0..2-1] of Char;      {= 主副标志 }
    smain_flag2: array[0..2-1] of Char;     {= 主副标志 }
    sbank_code: array[0..7-1] of Char;      {= 银行代码 }
    sbank_code2: array[0..7-1] of Char;     {= 银行代码2 }
    semp_no: array[0..9-1] of Char;         {= 工号 }

    semp_no2: array[0..9-1] of Char;        {=19 工号2 }
    drate0: Double;                         {= 比率 }
    drate1: Double;                         {= 比率1 }
    lserial0: LongInt;                      {= 序列号 0 }
    lserial1: LongInt;                      {= 序列号 1 }
    sbankname: array[0..81-1] of Char;      {= 银行名称 }
    sbankname2: array[0..81-1] of Char;     {= 银行名称2 }
    scard0: array[0..51-1] of Char;         {= 磁卡号码 }

    scard1: array[0..51-1] of Char;         {=20 磁卡号码 }
    sorder0: array[0..11-1] of Char;         {= 合同序号 }
    sorder1: array[0..11-1] of Char;         {= 合同序号 }
    sorder2: array[0..11-1] of Char;         {= 合同序号 }
    scusttypes: array[0..201-1] of Char;     {= 客户类别集合 }
    ssectypes: array[0..201-1] of Char;      {= 证券类别集合 }


    vsmess: array[0..256-1] of Char;        {= 23 信息 }
    vsvarstr0: array[0..256-1] of Char;     {= 变长的字符串 }
    vsvarstr1: array[0..256-1] of Char;     {= 变长的字符串 }
    vsvarstr2: array[0..256-1] of Char;     {= 变长的字符串 }
    vsvarstr3: array[0..256-1] of Char;     {= 变长的字符串 }
  end;
  PSTPack = ^TSTPack;

  TKCType = (kcEmpty,kcChar,kcInteger,kcFloat,kcVarChar,kcBit);


// 压缩数据，返回压缩以后的大小byte
function KCPackData(const ParamBits : TSTParamBits; const Data : TSTPack; Buffer : PByte):Integer;

// 解压缩数据，返回压缩的大小byte
function KCUnPackData(const ParamBits : TSTParamBits; var Data : TSTPack; Buffer : PByte):Integer;

procedure KCCheckDefine;

procedure KCClearParamBits(var ParamBits : TSTParamBits);

procedure KCPutStr(var CharArray; Size : Integer; const S:string);

function  KCGetStr(const CharArray; Size : Integer):string;

procedure KCDumpParamBits(const ParamBits : TSTParamBits);

procedure KCDumpPack(const Pack : TSTPack);

function  KCFindParam(const Name : string): Integer;

function  UnpackBits2Chars(BitsBuffer : PByte; BitsBufferSize : Integer; CharsBuffer : PChar; CharsBufferSize : Integer):Integer;

procedure PackChars2Bits(CharsBuffer : PChar; CharsBufferSize : Integer; BitsBuffer : PByte; BitsBufferSize : Integer);

const
  KCPackDataSizes : array[0..PARAMBITS-1] of Word =
  (
    // 0
    11,
    11,
    16,
    16,
    3,
    3,
    21,
    21,

    // 1
    81,
    2,
    2,
    9,
    9,
    9,
    9,
    9,

    // 2
    9,
    9,
    9,
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),

    // 3
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),

    // 4
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),

    // 5
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),

    // 6
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),

    // 7
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),

    // 8
    SizeOf(Double),
    SizeOf(Double),
    9,
    9,
    3,
    3,
    3,
    3,

    // 9
    4,
    4,
    7,
    7,
    7,
    7,
    7,
    4,

    // 10
    SizeOf(LongInt),
    9,
    9,
    9,
    9,
    9,
    9,
    9,

    // 11
    9,
    21,
    21,
    33,
    33,
    SizeOf(LongInt),
    SizeOf(LongInt),
    7,

    // 12
    7,
    31,
    31,
    31,
    31,
    61,
    61,
    81,

    // 13
    81,
    51,
    51,
    81,
    2,
    2,
    2,
    2,

    // 14
    2,
    SizeOf(LongInt),
    81,
    81,
    13,
    13,
    13,
    13,

    // 15
    13,
    3,
    3,
    4,
    4,
    4,
    100,
    100,

    // 16
    100,
    100,
    100,
    100,
    100,
    17,
    17,
    41,

    // 17
    41,
    SizeOf(LongInt),
    SizeOf(LongInt),
    2,
    2,
    7,
    7,
    9,

    // 18
    9,
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(LongInt),
    SizeOf(LongInt),
    81,
    81,
    51,

    // 19
    51,
    11,
    11,
    11,
    201,
    201,
    0,
    0,

    // 20
    0,0,0,0,0,0,0,0,

    // 21
    0,0,0,0,0,0,0,0,

    // 22
    256,
    256,
    256,
    256,
    256,
    0,
    0,
    0,

    // 23
    0,0,0,0,0,0,0,0,
    // 24
    0,0,0,0,0,0,0,0,
    // 25
    0,0,0,0,0,0,0,0,
    // 26
    0,0,0,0,0,0,0,0,
    // 27
    0,0,0,0,0,0,0,0,
    // 28
    0,0,0,0,0,0,0,0,
    // 29
    0,0,0,0,0,0,0,0,
    // 30
    0,0,0,0,0,0,0,0,
    // 31
    0,0,0,0,0,0,0,0
  );



  KCPackDataTypes : array[0..PARAMBITS-1] of TKCType=
  (
    // 0
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 1
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 2
    kcChar,
    kcChar,
    kcChar,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,

    // 3
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,

    // 4
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,

    // 5
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,

    // 6
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,

    // 7
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,

    // 8
    kcFloat,
    kcFloat,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 9
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 10
    kcInteger,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 11
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcInteger,
    kcInteger,
    kcChar,

    // 12
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 13
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 14
    kcChar,
    kcInteger,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 15
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcBit,
    kcBit,

    // 16
    kcBit,
    kcBit,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 17
    kcChar,
    kcInteger,
    kcInteger,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 18
    kcChar,
    kcFloat,
    kcFloat,
    kcInteger,
    kcInteger,
    kcChar,
    kcChar,
    kcChar,

    // 19
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcEmpty,
    kcEmpty,

    // 20
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,
    // 21
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,

    // 22
    kcVarChar,
    kcVarChar,
    kcVarChar,
    kcVarChar,
    kcVarChar,
    kcEmpty,
    kcEmpty,
    kcEmpty,

    // 23
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,
    // 24
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,
    // 25
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,
    // 26
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,
    // 27
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,
    // 28
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,
    // 29
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,
    // 30
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,
    // 31
    kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty,kcEmpty
  );

  KCPackDataNames : array[0..PARAMBITS-1] of string =
  (
    // 0
    'scust_no',
    'scust_no2',
    'sholder_ac_no',
    'sholder_ac_no2',
    'sholder_type',
    'sholder_type2',
    'sname',
    'sname2',

    // 1
    'sall_name',
    'smarket_code',
    'smarket_code2',
    'sdate0',
    'sdate1',
    'sdate2',
    'sdate3',
    'stime0',

    // 2
    'stime1',
    'stime2',
    'stime3',
    'lvol0' ,
    'lvol1' ,
    'lvol2' ,
    'lvol3' ,
    'lvol4' ,

    // 3
    'lvol5' ,
    'lvol6' ,
    'lvol7' ,
    'lvol8' ,
    'lvol9' ,
    'lvol10' ,
    'lvol11' ,
    'lvol12' ,

    // 4
    'damt0' ,
    'damt1' ,
    'damt2' ,
    'damt3' ,
    'damt4' ,
    'damt5' ,
    'damt6' ,
    'damt7' ,

    // 5
    'damt8' ,
    'damt9' ,
    'damt10' ,
    'damt11' ,
    'damt12' ,
    'damt13' ,
    'damt14' ,
    'damt15' ,

    // 6
    'damt16' ,
    'damt17' ,
    'damt18' ,
    'damt19' ,
    'damt20' ,
    'damt21' ,
    'damt22' ,
    'damt23' ,

    // 7
    'damt24' ,
    'damt25' ,
    'damt26' ,
    'damt27' ,
    'damt28' ,
    'damt29' ,
    'damt30' ,
    'damt31' ,

    // 8
    'damt32' ,
    'damt33' ,
    'sstock_code' ,
    'sstock_code2' ,
    'scust_type' ,
    'scust_type2' ,
    'sstat_type' ,
    'sstat_type2' ,

    // 9
    'sroom_no' ,
    'sroom_no2' ,
    'sopen_emp' ,
    'sclose_emp' ,
    'schange_emp' ,
    'scheck_emp' ,
    'semp' ,
    'snation_code' ,

    // 10
    'lcert_code' ,
    'stx_pwd',
    'stx_pwd2',
    'swithdraw_pwd',
    'swithdraw_pwd2' ,
    'semp_pwd'  ,
    'semp_pwd2'   ,
    'sbank_pwd'  ,

    // 11
    'sbank_pwd2'  ,
    'scust_auth'   ,
    'scust_auth2'   ,
    'scust_limit' ,
    'scust_limit2'  ,
    'lsafe_level' ,
    'lsafe_level2' ,
    'spost_code' ,

    // 12
    'spost_code2' ,
    'sphone' ,
    'sphone2' ,
    'sphone3' ,
    'spager' ,
    'semail' ,
    'semail2' ,
    'snote'  ,

    // 13
    'snote2'  ,
    'scert_no' ,
    'scert_no2' ,
    'scert_addr'  ,
    'sstatus0' ,
    'sstatus1' ,
    'sstatus2' ,
    'sstatus3' ,

    // 14
    'sstatus4' ,
    'lwithdraw_flag' ,
    'saddr'  ,
    'saddr2'  ,
    'sserial0'   ,
    'sserial1' ,
    'sserial2' ,
    'sserial3' ,

    // 15
    'sserial4',
    'scurrency_type'  ,
    'scurrency_type2'  ,
    'sbranch_code0' ,
    'sbranch_code1' ,
    'sbranch_code2' ,
    'usset0' ,
    'usset1' ,

    // 16
    'usset2' ,
    'usset3' ,
    'usset4' ,
    'usset5' ,
    'usset6' ,
    'sstation0' ,
    'sstation1' ,
    'sbank_acc' ,

    // 17
    'sbank_acc2' ,
    'lbank_acc_type' ,
    'lbank_acc_type2' ,
    'smain_flag' ,
    'smain_flag2' ,
    'sbank_code' ,
    'sbank_code2' ,
    'semp_no'  ,

    // 18
    'semp_no2'  ,
    'drate0' ,
    'drate1' ,
    'lserial0' ,
    'lserial1' ,
    'sbankname'  ,
    'sbankname2'  ,
    'scard0' ,

    // 19
    'scard1' ,
    'sorder0',
    'sorder1',
    'sorder2',
    'scusttypes',
    'ssectypes',
    '','',

    // 20
    '','','','','','','','',
    // 21
    '','','','','','','','',

    // 22
    'vsmess'  ,
    'vsvarstr0' ,
    'vsvarstr1' ,
    'vsvarstr2' ,
    'vsvarstr3' ,
    '','','',

    // 23
    '','','','','','','','',
    // 24
    '','','','','','','','',
    // 25
    '','','','','','','','',
    // 26
    '','','','','','','','',
    // 27
    '','','','','','','','',
    // 28
    '','','','','','','','',
    // 29
    '','','','','','','','',
    // 30
    '','','','','','','','',
    // 31
    '','','','','','','',''
  );

implementation

uses SysUtils,  LogFile;

// 压缩数据，返回压缩以后的大小byte
function KCPackData(const ParamBits : TSTParamBits; const Data : TSTPack; Buffer : PByte):Integer;
var
  I,J : Integer;
  Mask : Byte;
  Count : Integer;
  PData : PByte;
  ASize : Integer;
  DataSizeInBuffer : Smallint;
begin
  PData := PByte(@Data);
  Count := 0;
  Result := 0;
  for I:=0 to ParamBitsSize-1 do
  begin
    Mask := 1;
    for J:=0 to BITSPERBYTE-1 do
    begin
      ASize := KCPackDataSizes[Count];
      if (ParamBits[I] and Mask)<>0 then
      begin
        Assert(KCPackDataTypes[Count]<>kcEmpty);
        if KCPackDataTypes[Count]=kcVarChar then
        begin
          DataSizeInBuffer := StrLen(PChar(PData)); // exclude #0
          Assert(DataSizeInBuffer<ASize); // must #0 end
          // copy the size to buffer
          Inc(DataSizeInBuffer); // include #0
          Move(DataSizeInBuffer,Buffer^,SizeOf(DataSizeInBuffer));
          Inc(Buffer,SizeOf(DataSizeInBuffer));
          Inc(Result,SizeOf(DataSizeInBuffer));
          // copy data
          Move(PData^,Buffer^,DataSizeInBuffer);
        end else
        begin
          DataSizeInBuffer := ASize;
          Move(PData^,Buffer^,ASize);
        end;
        Inc(Buffer,DataSizeInBuffer);
        Inc(Result,DataSizeInBuffer);
      end;
      Inc(PData,ASize);
      Inc(Count);
      Mask := Mask shl 1;
    end;
  end;
end;

// 解压缩数据，返回压缩的大小byte
function KCUnPackData(const ParamBits : TSTParamBits; var Data : TSTPack; Buffer : PByte):Integer;
var
  I,J : Integer;
  Mask : Byte;
  Count : Integer;
  PData : PByte;
  ASize : Integer;
  DataSizeInBuffer : Smallint;
begin
  PData := PByte(@Data);
  Count := 0;
  Result := 0;
  FillChar(PData^,SizeOf(Data),0); // 初始化
  for I:=0 to ParamBitsSize-1 do
  begin
    Mask := 1;
    for J:=0 to BITSPERBYTE-1 do
    begin
      ASize := KCPackDataSizes[Count];
      if (ParamBits[I] and Mask)<>0 then
      begin
        Assert(KCPackDataTypes[Count]<>kcEmpty);
        if KCPackDataTypes[Count]=kcVarChar then
        begin
          // get the size from buffer
          Move(Buffer^,DataSizeInBuffer,SizeOf(DataSizeInBuffer)); // include #0
          Assert((DataSizeInBuffer>0) and (DataSizeInBuffer<=ASize)); // must #0 end
          Inc(Buffer,SizeOf(DataSizeInBuffer));
          Inc(Result,SizeOf(DataSizeInBuffer));
          Move(Buffer^,PData^,DataSizeInBuffer);
        end
        else
        begin
          DataSizeInBuffer := ASize;
          Move(Buffer^,PData^,ASize);
        end;
        Inc(Buffer,DataSizeInBuffer);
        Inc(Result,DataSizeInBuffer);
      end;
      Inc(PData,ASize);
      Inc(Count);
      Mask := Mask shl 1;
    end;
  end;
end;

resourcestring
  AssertError='定义的包结构错误！';

procedure KCCheckDefine;
var
  I : Integer;
  Count : Integer;
begin
  Count := 0;
  for I:=0 to PARAMBITS-1 do
  begin
    Inc(Count, KCPackDataSizes[I]);
    if KCPackDataTypes[I]<>kcEmpty then
      Assert(KCPackDataNames[I]<>'',AssertError) else
      Assert(KCPackDataNames[I]='',AssertError);
    case KCPackDataTypes[I] of
      kcEmpty : Assert(KCPackDataSizes[I]=0,AssertError);
      kcChar, kcVarChar : Assert(KCPackDataSizes[I]>0,AssertError);
      kcInteger : Assert((KCPackDataSizes[I]=Sizeof(LongInt)),AssertError);
      kcFloat : Assert(KCPackDataSizes[I]=SizeOf(Double),AssertError);
      kcBit : Assert(KCPackDataSizes[I]=100,AssertError);
    else
      Assert(KCPackDataSizes[I]=0,AssertError);
    end;
  end;
  Assert(Count=SizeOf(TSTPack),AssertError);
end;

procedure KCClearParamBits(var ParamBits : TSTParamBits);
begin
  FillChar(ParamBits,SizeOf(ParamBits),0);
end;

procedure KCPutStr(var CharArray; Size : Integer; const S:string);
var
  CopySize : Integer;
begin
  Assert(Size>0);
  FillChar(CharArray,Size,0);
  if S<>'' then
  begin
    CopySize := Length(S);
    if CopySize>Size-1 then  // last char in CharArray is #0 , cannot be overwrite
      CopySize := Size-1;
    Move(PChar(S)^,CharArray,CopySize);
  end;
end;

function  KCGetStr(const CharArray; Size : Integer):string;
begin
  Assert(Size>0);
  SetLength(Result,Size);
  FillChar(PChar(Result)^,Size+1,0);
  Move(CharArray, PChar(Result)^,Size);
  SetLength(Result,StrLen(PChar(Result)));
  { TODO : 恢复断言 }
  //Assert(Length(Result)<Size); // last char in CharArray is #0 , cannot be overwrite
end;

{$ifndef debug }
procedure KCDumpParamBits(const ParamBits : TSTParamBits);
begin

end;

procedure KCDumpPack(const Pack : TSTPack);
begin

end;

{$else}

procedure KCDumpParamBits(const ParamBits : TSTParamBits);
var
  I,J : Integer;
  Mask : Byte;
  S : string;
begin
  WriteLog('ParamBits',lcKCPack);
  for I:=0 to ParamBitsSize-1 do
  begin
    Mask := 1;
    S := '';
    for J:=0 to BITSPERBYTE do
    begin
      if (ParamBits[I] and Mask)<>0 then
        S := S+'1' else
        S := S+'0';
      Mask := Mask shl 1;
    end;
    WriteLog(S,lcKCPack);
  end;
end;

procedure KCDumpPack(const Pack : TSTPack);
var
  I : Integer;
  PData : PByte;
  S : string;
  K : Longint;
  D : Double;
  ASize : Integer;
begin
  WriteLog('Pack',lcKCPackDetail);
  PData := PByte(@Pack);
  for I:=0 to PARAMBITS-1 do
  begin
    ASize := KCPackDataSizes[I];
    case KCPackDataTypes[I] of
      kcChar :begin
                S := KCGetStr(PData^,ASize);
                WriteLog(Format('%s=%s',[KCPackDataNames[I],S]),lcKCPackDetail);
              end;
      kcInteger:
              begin
                K := 0;
                Move(PData^,K,ASize);
                WriteLog(Format('%s=%d',[KCPackDataNames[I],K]),lcKCPackDetail);
              end;
      kcFloat :
              begin
                D := 0;
                Move(PData^,D,ASize);
                WriteLog(Format('%s=%f',[KCPackDataNames[I],D]),lcKCPackDetail);
              end;
    end;
    Inc(PData,ASize);
  end;
end;

{$endif}

function  KCFindParam(const Name : string): Integer;
var
  I : Integer;
begin
  if Name<>'' then
    for I:=0 to PARAMBITS-1 do
      if SameText(Name,KCPackDataNames[I]) then
      begin
        Result := I;
        Exit;
      end;
  Result := -1;
end;

procedure PackChars2Bits(CharsBuffer : PChar; CharsBufferSize : Integer; BitsBuffer : PByte; BitsBufferSize : Integer);
var
  BitsIndex, CharsIndex,I : Integer;
  Bits : Byte;
  SetBit : Byte;
begin
  FillChar(BitsBuffer^,BitsBufferSize,0);
  CharsIndex:=0;
  for BitsIndex:=1 to BitsBufferSize do
  begin
    Bits := 0;
    for I:=1 to 8 do
    begin
      SetBit := 0;
      if CharsIndex<CharsBufferSize then
      begin
        if CharsBuffer^ = '1' then
          SetBit := 1;
        Inc(CharsBuffer);
        Inc(CharsIndex);
      end;
      Bits := (Bits shl 1) or SetBit;
    end;
    BitsBuffer^ := Bits;
    Inc(BitsBuffer);
    if CharsIndex>=CharsBufferSize then
      Break;
  end;
end;

function  UnpackBits2Chars(BitsBuffer : PByte; BitsBufferSize : Integer; CharsBuffer : PChar; CharsBufferSize : Integer):Integer;
var
  BitsIndex, CharsIndex,I : Integer;
  Bits : Byte;
begin
  FillChar(CharsBuffer^,CharsBufferSize,Ord('0'));
  CharsIndex:=0;
  for BitsIndex:=1 to BitsBufferSize do
  begin
    Bits := BitsBuffer^;
    for I:=1 to 8 do
    begin
      if CharsIndex>=CharsBufferSize then
      begin
        Result := CharsIndex;
        Exit;
      end;
      if (Bits and $80)<>0 then
        CharsBuffer^ := '1' else
        CharsBuffer^ := '0';
      Inc(CharsBuffer);
      Inc(CharsIndex);

      Bits := Bits shl 1;
    end;
    Inc(BitsBuffer);
  end;
  Result := CharsIndex;
end;

initialization
  KCCheckDefine;

end.
